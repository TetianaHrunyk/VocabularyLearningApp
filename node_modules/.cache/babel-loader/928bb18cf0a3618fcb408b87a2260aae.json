{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\n\nconst useFetch = (url, method, authentication, deleted, created, deck) => {\n  _s();\n\n  const [data, setData] = useState(null);\n  const [isPending, setIsPending] = useState(true);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const abortCont = new AbortController();\n    fetch(url, {\n      'signal': abortCont.signal,\n      'method': method,\n      'headers': {\n        Authorization: authentication,\n        'Content-Type': 'application/json'\n      }\n    }).then(res => {\n      if (!res.ok) {\n        throw Error('could not fetch the data for that resource');\n      }\n\n      return res.json();\n    }).then(data => {\n      setIsPending(false);\n      setData(data);\n      setError(null);\n    }).catch(err => {\n      if (err.name === 'AbortError') {\n        console.log('fetch aborted');\n      } else {\n        // auto catches network / connection error\n        setIsPending(false);\n        setError(err.message);\n      }\n\n      console.log(err.message);\n    }); // abort the fetch\n\n    return () => abortCont.abort();\n  }, [url, method, authentication, deleted, created, deck]);\n  return {\n    data,\n    isPending,\n    error\n  };\n};\n\n_s(useFetch, \"VxPkICXS4AfkXU1R8tuEJAA8e58=\");\n\nexport default useFetch;","map":{"version":3,"sources":["/home/tania/Documents/uni/uniba2nd/TIA/vocs/src/hooks/useGetData.js"],"names":["useState","useEffect","useFetch","url","method","authentication","deleted","created","deck","data","setData","isPending","setIsPending","error","setError","abortCont","AbortController","fetch","signal","Authorization","then","res","ok","Error","json","catch","err","name","console","log","message","abort"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;;AAEA,MAAMC,QAAQ,GAAG,CAACC,GAAD,EAAMC,MAAN,EAAcC,cAAd,EAA8BC,OAA9B,EAAuCC,OAAvC,EAAgDC,IAAhD,KAAyD;AAAA;;AACxE,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBV,QAAQ,CAAC,IAAD,CAAhC;AACA,QAAM,CAACW,SAAD,EAAYC,YAAZ,IAA4BZ,QAAQ,CAAC,IAAD,CAA1C;AACA,QAAM,CAACa,KAAD,EAAQC,QAAR,IAAoBd,QAAQ,CAAC,IAAD,CAAlC;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMc,SAAS,GAAG,IAAIC,eAAJ,EAAlB;AACEC,IAAAA,KAAK,CAACd,GAAD,EACH;AACE,gBAAUY,SAAS,CAACG,MADtB;AAEE,gBAAUd,MAFZ;AAGE,iBAAW;AACTe,QAAAA,aAAa,EAAEd,cADN;AAET,wBAAgB;AAFP;AAHb,KADG,CAAL,CAUCe,IAVD,CAUMC,GAAG,IAAI;AACX,UAAI,CAACA,GAAG,CAACC,EAAT,EAAa;AACX,cAAMC,KAAK,CAAC,4CAAD,CAAX;AACD;;AACD,aAAOF,GAAG,CAACG,IAAJ,EAAP;AACD,KAfD,EAgBCJ,IAhBD,CAgBMX,IAAI,IAAI;AACZG,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,MAAAA,OAAO,CAACD,IAAD,CAAP;AACAK,MAAAA,QAAQ,CAAC,IAAD,CAAR;AACD,KApBD,EAqBCW,KArBD,CAqBOC,GAAG,IAAI;AACZ,UAAIA,GAAG,CAACC,IAAJ,KAAa,YAAjB,EAA+B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ;AACD,OAFD,MAEO;AACL;AACAjB,QAAAA,YAAY,CAAC,KAAD,CAAZ;AACAE,QAAAA,QAAQ,CAACY,GAAG,CAACI,OAAL,CAAR;AACD;;AACDF,MAAAA,OAAO,CAACC,GAAR,CAAYH,GAAG,CAACI,OAAhB;AACD,KA9BD,EAFY,CAkCd;;AACA,WAAO,MAAMf,SAAS,CAACgB,KAAV,EAAb;AACD,GApCQ,EAoCN,CAAC5B,GAAD,EAAMC,MAAN,EAAcC,cAAd,EAA8BC,OAA9B,EAAuCC,OAAvC,EAAgDC,IAAhD,CApCM,CAAT;AAsCA,SAAO;AAAEC,IAAAA,IAAF;AAAQE,IAAAA,SAAR;AAAmBE,IAAAA;AAAnB,GAAP;AACD,CA5CD;;GAAMX,Q;;AA8CN,eAAeA,QAAf","sourcesContent":["import { useState, useEffect } from 'react';\n\nconst useFetch = (url, method, authentication, deleted, created, deck) => {\n  const [data, setData] = useState(null);\n  const [isPending, setIsPending] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const abortCont = new AbortController();\n      fetch(url, \n        { \n          'signal': abortCont.signal,\n          'method': method,\n          'headers': {\n            Authorization: authentication,\n            'Content-Type': 'application/json'\n          }\n        }\n      )\n      .then(res => {\n        if (!res.ok) { \n          throw Error('could not fetch the data for that resource');\n        } \n        return res.json();\n      })\n      .then(data => {\n        setIsPending(false);\n        setData(data);\n        setError(null);\n      })\n      .catch(err => {\n        if (err.name === 'AbortError') {\n          console.log('fetch aborted')\n        } else {\n          // auto catches network / connection error\n          setIsPending(false);\n          setError(err.message);\n        }\n        console.log(err.message)\n      })\n\n    // abort the fetch\n    return () => abortCont.abort();\n  }, [url, method, authentication, deleted, created, deck])\n\n  return { data, isPending, error };\n}\n \nexport default useFetch;"]},"metadata":{},"sourceType":"module"}